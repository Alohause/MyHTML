<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Sakura Vision - Final Atmosphere</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.2/dist/gsap.min.js"></script>
    
    <style>
        body { margin: 0; overflow: hidden; background-color: #020202; font-family: 'Segoe UI', sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        /* 视频反馈窗口 */
        #video-container {
            position: fixed; bottom: 20px; right: 20px; 
            width: 180px; height: 135px;
            z-index: 10; pointer-events: none;
            border-radius: 12px; overflow: hidden;
            border: 2px solid rgba(255,182,193,0.3);
            background: rgba(0,0,0,0.8);
            box-shadow: 0 4px 20px rgba(0,0,0,0.6);
            transition: opacity 0.3s;
        }
        #video-input { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); opacity: 0.6; }
        
        /* UI 覆盖层 */
        .ui-overlay { 
            position: fixed; top: 30px; left: 30px; z-index: 10;
            color: rgba(255,255,255,0.95); pointer-events: none;
            text-shadow: 0 0 20px rgba(255,105,180,0.5);
        }
        h1 { margin: 0; font-weight: 200; letter-spacing: 0.25em; font-size: 2rem; }
        .status-text { 
            font-size: 1rem; color: #ffb7c5; margin-top: 12px; 
            font-weight: 600; letter-spacing: 1px;
            padding: 8px 16px; background: rgba(0,0,0,0.4);
            border-radius: 4px; display: inline-block;
            backdrop-filter: blur(4px);
        }
        
        /* 上传按钮美化 */
        #upload-btn-label {
            position: fixed; bottom: 40px; left: 50%; transform: translateX(-50%); z-index: 10;
            padding: 12px 40px;
            background: rgba(20, 20, 20, 0.6); 
            border: 1px solid rgba(255,182,193,0.4);
            color: rgba(255,182,193,1); cursor: pointer; border-radius: 50px;
            backdrop-filter: blur(10px); transition: all 0.4s cubic-bezier(0.23, 1, 0.32, 1);
            font-size: 0.85rem; letter-spacing: 3px; text-transform: uppercase;
            box-shadow: 0 0 15px rgba(0,0,0,0.5);
            text-align: center;
        }
        #upload-btn-label:hover { 
            background: rgba(255,182,193,0.15); 
            border-color: rgba(255,182,193,0.8);
            box-shadow: 0 0 30px rgba(255,182,193,0.3); 
            transform: translateX(-50%) translateY(-2px);
        }
        #upload-btn { display: none; }

        /* 加载动画 */
        #loading {
            position: fixed; top:0; left:0; width:100%; height:100%;
            background: #020202; z-index: 99; color: #ffb7c5;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            transition: opacity 0.8s;
        }
        .loader-bar { width: 200px; height: 2px; background: rgba(255,182,193,0.2); margin-top: 15px; position: relative; overflow: hidden; }
        .loader-bar::after {
            content:''; position: absolute; top:0; left:0; width: 100%; height: 100%;
            background: #ffb7c5; transform: translateX(-100%);
            animation: load 1.5s infinite ease-in-out;
        }
        @keyframes load { 0% { transform: translateX(-100%); } 100% { transform: translateX(100%); } }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

<div id="loading">
    <div style="font-size: 24px; letter-spacing: 6px; font-weight: 300;">SAKURA VISION</div>
    <div style="font-size: 12px; opacity: 0.6; letter-spacing: 2px; margin-top: 5px;">SYSTEM INITIALIZING</div>
    <div class="loader-bar"></div>
</div>

<div id="canvas-container"></div>
<div id="video-container"><video id="video-input"></video></div>

<div class="ui-overlay">
    <h1>AETHER BLOOM</h1>
    <div id="status-display" class="status-text">等待手势指令...</div>
    <div style="font-size: 0.75rem; margin-top:8px; opacity: 0.6; letter-spacing: 1px;">
        交互: 捏合(抓取照片) | 握拳(树形态) | 张开(散开旋转)
    </div>
</div>

<label id="upload-btn-label" for="upload-btn">
    + 上传记忆碎片
</label>
<input type="file" id="upload-btn" accept="image/*" multiple>

<script type="module">
import * as THREE from 'three';
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

// --- 配置 ---
const CONFIG = {
    petalCount: 4000, 
    trunkParticleCount: 3000,
    colors: [0xffffff, 0xffc0cb, 0xff69b4, 0xeeb4b4], 
    trunkColor: 0x8B4513,
    skyHeight: 12,
    bloomThreshold: 0.85, 
    bloomStrength: 1.2,
    sparkleChance: 0.992
};

// --- 背景粒子配色盘 ---
const BG_PALETTE = [
    0xFFF44F, // 柠檬黄
    0xFFFFFF, // 白
    0x87CEEB, // 天蓝
    0x98FB98, // 嫩绿
    0xFFB7C5  // 淡粉
];

let scene, camera, renderer, composer;
let petalsMesh, trunkMesh, bgParticles; 
let photos = []; 
let targetPositions = []; 
let trunkPositions = [];  

let currentState = 'closed'; 
let handData = { x: 0.5, y: 0.5, active: false }; 
let time = 0;
let frameCounter = 0;

const dummy = new THREE.Object3D();
const _pos = new THREE.Vector3();
const _scale = new THREE.Vector3();
const _color = new THREE.Color(); 
const _sparkleColor = new THREE.Color(10, 10, 10); 

// --- 初始化 ---
async function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x020202);
    scene.fog = new THREE.FogExp2(0x020202, 0.04);

    camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 100);
    camera.position.set(0, 4, 11); 
    camera.lookAt(0, 3, 0);

    renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
    renderer.toneMapping = THREE.ReinhardToneMapping;
    renderer.toneMappingExposure = 1.2;
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    const ambient = new THREE.AmbientLight(0x333333);
    scene.add(ambient);
    const moonLight = new THREE.DirectionalLight(0xaaddff, 0.8);
    moonLight.position.set(10, 20, 10);
    scene.add(moonLight);

    generateStructure();
    createTrunkParticles();
    createPetals();
    createBgParticles(); 
    initPostProcessing();
    
    initHandTracking();
    animate();

    const loader = document.getElementById('loading');
    setTimeout(() => {
        loader.style.opacity = 0;
        setTimeout(() => loader.remove(), 800);
    }, 1200);
}

function initPostProcessing() {
    const renderScene = new RenderPass(scene, camera);
    const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
    bloomPass.threshold = CONFIG.bloomThreshold;
    bloomPass.strength = CONFIG.bloomStrength;
    bloomPass.radius = 0.6;
    
    composer = new EffectComposer(renderer);
    composer.addPass(renderScene);
    composer.addPass(bloomPass);
}

function createBgParticles() {
    const particleCount = 2500;
    const geom = new THREE.BufferGeometry();
    const positions = [];
    const colors = [];
    
    for(let i = 0; i < particleCount; i++) {
        const x = (Math.random() - 0.5) * 70;
        const y = (Math.random() - 0.5) * 50 + 10;
        const z = (Math.random() - 0.5) * 70;
        positions.push(x, y, z);

        const hex = BG_PALETTE[Math.floor(Math.random() * BG_PALETTE.length)];
        _color.setHex(hex);
        _color.multiplyScalar(0.6); 
        colors.push(_color.r, _color.g, _color.b);
    }
    
    geom.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    geom.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
    
    const mat = new THREE.PointsMaterial({
        size: 0.06,
        vertexColors: true, 
        transparent: true,
        opacity: 0.8, 
        blending: THREE.NormalBlending 
    });
    
    bgParticles = new THREE.Points(geom, mat);
    scene.add(bgParticles);
}

function generateStructure() {
    function createBranchData(startPos, length, rotation, depth) {
        const segments = Math.floor(length * 10);
        const dir = new THREE.Vector3(0, 1, 0).applyEuler(rotation);
        for(let i=0; i<=segments; i++) {
            const progress = i / segments;
            const pos = startPos.clone().add(dir.clone().multiplyScalar(length * progress));
            const thickness = 0.35 * depth * (1 - progress); 
            pos.x += (Math.random()-0.5) * thickness;
            pos.z += (Math.random()-0.5) * thickness;
            trunkPositions.push(pos);
        }
        if (depth === 0) {
            const tip = startPos.clone().add(dir.multiplyScalar(length));
            for(let k=0; k<15; k++) {
                targetPositions.push(tip.clone().add(new THREE.Vector3((Math.random()-0.5)*2.5, (Math.random()-0.5)*2.0, (Math.random()-0.5)*2.5)));
            }
            return;
        }
        const endPos = startPos.clone().add(dir.multiplyScalar(length));
        for (let i = 0; i < 2; i++) {
             const newRot = new THREE.Euler(rotation.x + (Math.random()-0.5)*1.2, rotation.y + (Math.random()-0.5)*1.5 + 0.8, rotation.z + (Math.random()-0.5)*1.2);
            createBranchData(endPos, length * 0.8, newRot, depth - 1);
        }
    }
    createBranchData(new THREE.Vector3(0, -2.5, 0), 3.5, new THREE.Euler(0,0,0), 4);
}

function createTrunkParticles() {
    const geo = new THREE.BoxGeometry(0.06, 0.06, 0.06);
    const mat = new THREE.MeshStandardMaterial({ 
        color: CONFIG.trunkColor, 
        emissive: 0x552211, 
        emissiveIntensity: 0.2, 
        roughness: 0.8 
    });
    trunkMesh = new THREE.InstancedMesh(geo, mat, trunkPositions.length);
    trunkPositions.forEach((pos, i) => {
        dummy.position.copy(pos); 
        dummy.rotation.set(Math.random(),Math.random(),Math.random()); 
        dummy.updateMatrix();
        trunkMesh.setMatrixAt(i, dummy.matrix);
    });
    scene.add(trunkMesh);
}

function createPetals() {
    const geo = new THREE.PlaneGeometry(0.09, 0.09);
    const posAttr = geo.attributes.position;
    for(let i=0; i<posAttr.count; i++){ posAttr.setZ(i, posAttr.getZ(i) + Math.abs(posAttr.getX(i))*0.4); }
    geo.computeVertexNormals();

    const mat = new THREE.MeshBasicMaterial({ side: THREE.DoubleSide, transparent: true, opacity: 0.9 });
    const count = Math.max(CONFIG.petalCount, targetPositions.length);
    petalsMesh = new THREE.InstancedMesh(geo, mat, count);

    for (let i = 0; i < count; i++) {
        const baseColor = new THREE.Color(CONFIG.colors[i % CONFIG.colors.length]);
        baseColor.offsetHSL(0, (Math.random()-0.5)*0.1, 0);
        baseColor.multiplyScalar(0.7);
        
        petalsMesh.setColorAt(i, baseColor);

        const canSparkle = Math.random() < 0.2; 
        
        petalsMesh.userData[i] = {
            homePos: targetPositions[i % targetPositions.length] || new THREE.Vector3(0,0,0),
            scatterPos: new THREE.Vector3((Math.random()-0.5) * 25, CONFIG.skyHeight + (Math.random()-0.5) * 8, (Math.random()-0.5) * 20),
            phase: Math.random() * Math.PI * 2,
            baseColor: baseColor.clone(),
            canSparkle: canSparkle,
            sparkleSpeed: 1.0 + Math.random() * 3.0, 
            flashIntensity: 0
        };
        dummy.position.copy(petalsMesh.userData[i].homePos); dummy.updateMatrix();
        petalsMesh.setMatrixAt(i, dummy.matrix);
    }
    scene.add(petalsMesh);
}

async function initHandTracking() {
    const video = document.getElementById('video-input');
    const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
    
    hands.setOptions({ maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
    
    hands.onResults((results) => {
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const lm = results.multiHandLandmarks[0];
            handData.active = true;
            handData.x = 1 - lm[9].x; handData.y = lm[9].y;
            detectGesture(lm);
        } else {
            handData.active = false;
        }
    });

    const cameraUtils = new Camera(video, { 
        onFrame: async () => { 
            frameCounter++;
            if (frameCounter % 3 === 0) { 
                await hands.send({image: video}); 
            }
        }, 
        width: 640, height: 480 
    });
    cameraUtils.start();
}

function detectGesture(lm) {
    const fingerTips = [8, 12, 16, 20];
    const dists = fingerTips.map(tip => Math.hypot(lm[tip].x - lm[0].x, lm[tip].y - lm[0].y));
    const avgDist = dists.reduce((a, b) => a + b) / 4;
    const pinch = Math.hypot(lm[8].x - lm[4].x, lm[8].y - lm[4].y);
    const statusEl = document.getElementById('status-display');
    
    let nextState = currentState;

    if (avgDist < 0.25) { 
        nextState = 'closed'; 
        statusEl.innerText = "状态：聚合 (樱树形态)"; 
        statusEl.style.color = "#ffb7c5"; 
    } else if (pinch < 0.08) { 
        nextState = 'focused'; 
        statusEl.innerText = "状态：抓取 (记忆显现)"; 
        statusEl.style.color = "#ffffff"; 
    } else if (avgDist > 0.35) { 
        nextState = 'scattered'; 
        statusEl.innerText = "状态：散开 (视角旋转)"; 
        statusEl.style.color = "#87ceeb"; 
    }

    if (nextState !== currentState) {
        currentState = nextState;
        
        // --- 状态联动 ---
        if (bgParticles) {
            if (currentState === 'focused') {
                gsap.to(bgParticles.material, { opacity: 0.3, duration: 0.8 });
            } else {
                gsap.to(bgParticles.material, { opacity: 0.8, duration: 0.8 });
            }
        }

        if (currentState === 'focused') {
            if (photos.length > 0) {
                const randomIndex = Math.floor(Math.random() * photos.length);
                photos.forEach((p, index) => {
                    if (index === randomIndex) {
                        const dir = new THREE.Vector3();
                        camera.getWorldDirection(dir);
                        const targetPos = camera.position.clone().add(dir.multiplyScalar(4));

                        gsap.to(p.position, {
                            x: targetPos.x, y: targetPos.y, z: targetPos.z,
                            duration: 0.8, ease: "back.out(1.2)"
                        });
                        gsap.to(p.scale, {
                            x: 0.5, y: 0.5, z: 0.5, 
                            duration: 0.8, ease: "back.out(1.2)"
                        });
                        gsap.to(p.quaternion, {
                            x: camera.quaternion.x, y: camera.quaternion.y, z: camera.quaternion.z, w: camera.quaternion.w,
                            duration: 0.8
                        });
                    } else {
                        gsap.to(p.scale, {x:0, y:0, z:0, duration: 0.3});
                    }
                });
            }
        } else {
            photos.forEach(p => {
                if(p.userData.origin) {
                    gsap.to(p.position, {
                        x: p.userData.origin.x, y: p.userData.origin.y, z: p.userData.origin.z,
                        duration: 0.6
                    });
                }
                gsap.to(p.scale, {x:0, y:0, z:0, duration:0.5, ease: "power2.in"});
            });
        }
    }
}

function animate() {
    requestAnimationFrame(animate);
    time += 0.01;

    const targetPos = new THREE.Vector3();
    const targetLook = new THREE.Vector3();
    let lerpSpeed = 0.03;

    if (currentState === 'closed') {
        targetPos.set(0, 4, 11);
        targetLook.set(0, 3, 0);
        lerpSpeed = 0.05;
    } else {
        lerpSpeed = handData.active ? 0.08 : 0.02;
        let angle = Math.sin(time * 0.1) * 0.3;
        let heightOffset = 0;
        
        if (handData.active) {
            angle = (handData.x - 0.5) * Math.PI * 1.0; 
            heightOffset = (handData.y - 0.5) * 3; 
        }
        
        const radius = currentState === 'focused' ? 10 : 13; 
        
        targetPos.set(Math.sin(angle) * radius, CONFIG.skyHeight + heightOffset, Math.cos(angle) * radius);
        targetLook.set(0, CONFIG.skyHeight, 0);
    }

    camera.position.lerp(targetPos, lerpSpeed);
    const currentLook = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion).add(camera.position);
    currentLook.lerp(targetLook, lerpSpeed);
    camera.lookAt(currentLook);

    if (petalsMesh) {
        let colorNeedsUpdate = false;
        for (let i = 0; i < petalsMesh.count; i++) {
            petalsMesh.getMatrixAt(i, dummy.matrix);
            dummy.matrix.decompose(_pos, new THREE.Quaternion(), _scale);
            const data = petalsMesh.userData[i];
            
            let target = currentState === 'closed' ? data.homePos : data.scatterPos;
            let moveSpeed = currentState === 'closed' ? 0.05 : 0.02;
            
            _pos.lerp(target, moveSpeed);
            
            if(currentState !== 'closed') {
                 _pos.y += Math.sin(time * 1.5 + data.phase) * 0.008;
                 _pos.x += Math.cos(time * 1.2 + data.phase) * 0.008;
                 dummy.rotation.x += 0.01; dummy.rotation.y += 0.015;
            } else {
                 dummy.rotation.set(0,0,0);
            }

            dummy.position.copy(_pos); dummy.updateMatrix();
            petalsMesh.setMatrixAt(i, dummy.matrix);

            if (data.canSparkle) {
                const sparkleVal = (Math.sin(time * data.sparkleSpeed + data.phase) + 1) / 2;
                const intensity = Math.pow(sparkleVal, 15); 

                if (intensity > 0.05) {
                    const finalColor = data.baseColor.clone().lerp(_sparkleColor, intensity * 0.9);
                    petalsMesh.setColorAt(i, finalColor);
                    colorNeedsUpdate = true;
                } else {
                    petalsMesh.setColorAt(i, data.baseColor);
                    colorNeedsUpdate = true;
                }
            } else {
                 petalsMesh.setColorAt(i, data.baseColor);
            }
        }
        petalsMesh.instanceMatrix.needsUpdate = true;
        if(colorNeedsUpdate) petalsMesh.instanceColor.needsUpdate = true;
    }

    if (bgParticles) {
        bgParticles.rotation.y += 0.0005;
        bgParticles.rotation.z += 0.0002;
        
        const colors = bgParticles.geometry.attributes.color;
        const particleCount = colors.count;
        
        for(let k=0; k<30; k++) {
            const idx = Math.floor(Math.random() * particleCount);
            const hex = BG_PALETTE[Math.floor(Math.random() * BG_PALETTE.length)];
            _color.setHex(hex).multiplyScalar(0.6); 
            colors.setXYZ(idx, _color.r, _color.g, _color.b);
        }
        colors.needsUpdate = true;
    }

    if(trunkMesh) trunkMesh.material.emissiveIntensity = 0.2 + Math.abs(Math.sin(time * 0.5))*0.1;
    
    composer.render();
}

document.getElementById('upload-btn').onchange = (e) => {
    Array.from(e.target.files).forEach((file, index) => {
        const url = URL.createObjectURL(file);
        new THREE.TextureLoader().load(url, (tex) => {
            tex.colorSpace = THREE.SRGBColorSpace;
            const ratio = tex.image.width / tex.image.height;
            const width = 3; 
            const height = width / ratio;
            
            // --- 核心修改：设置照片材质颜色为 0.8, 0.8, 0.8 ---
            // 确保其最大亮度 < 0.85 (阈值)，从而不触发 Bloom
            const material = new THREE.MeshBasicMaterial({
                map: tex, 
                side: THREE.DoubleSide, 
                transparent: true, 
                toneMapped: false,
                color: new THREE.Color(0.8, 0.8, 0.8) 
            });
            
            const mesh = new THREE.Mesh(new THREE.PlaneGeometry(width, height), material);
            
            const r = 8 + Math.random() * 4;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            
            mesh.position.set(
                r * Math.sin(phi) * Math.cos(theta),
                CONFIG.skyHeight + (Math.random()-0.5) * 6,
                r * Math.sin(phi) * Math.sin(theta)
            );
            
            mesh.userData.origin = mesh.position.clone();
            
            mesh.rotation.z = (Math.random() - 0.5) * 0.2;
            mesh.rotation.y = (Math.random() - 0.5) * 0.5;

            mesh.scale.set(0,0,0); 
            
            const borderGeo = new THREE.EdgesGeometry(mesh.geometry);
            const borderMat = new THREE.LineBasicMaterial({ color: 0xffffff, opacity: 0.5, transparent: true });
            mesh.add(new THREE.LineSegments(borderGeo, borderMat));
            
            scene.add(mesh);
            photos.push(mesh);
        });
    });
};

window.onresize = () => {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    composer.setSize(window.innerWidth, window.innerHeight);
};

init();
</script>
</body>
</html>